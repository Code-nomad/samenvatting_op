<html>
    <head>
        <title>Objectgericht Programmeren Samenvatting</title>
        <link rel="stylesheet" type="text/css" href="/css/highlight.css">
        <link rel="stylesheet" type="text/css" href="/css/styles.css">
        <meta charset="UTF-8">
    </head>
    <body>
        <h1 id="object-gericht-programmeren">Object Gericht Programmeren</h1>

<ul>
    
    <li>
        <h1 id="totaal-programmeren">Totaal Programmeren</h1>

<p>Behandelt alle mogelijke cases in de methode zelf. Returned altijd op een <em>normale</em> manier, zonder exceptions of dergelijke. Er worden ook <strong>geen</strong> pre-condities geven, alle edge-cases worden in de methode zelf behandeld en geven toch een uitkomst.</p>

<p>Een <em>totale</em> constructor geeft altijd een goed geinitialiseerd object terug.</p>

<p>Een mutator veranderd telkens de state en returned zonder side-effects.</p>

<p>Een inspector geeft altijd een resultaat.</p>


        
    </li>
    
    <li>
        <h1 id="annotations">Annotations</h1>

<p>Komen voor een methode en geven extra eigenschappen aan. @Basic, @Immutable, @Override, @Deprecated, . . . Annotaties beginnen altijd met een hoofdletter.</p>

<!--more-->

<p>@Basic</p>

<ul>
  <li>Alle basic methoden geven samen de state van het object aan.</li>
  <li>Zijn onafhankelijk (de zelfde informatie kan je niet bekomen in termen van andere basic methoden)</li>
  <li>Is geen <em>predefined</em> annotatie</li>
</ul>

<p>@Immutable geeft <strong>altijd</strong> de zelfde waarde terug. Kan verschillen van object tot object, maar veranderd niet als de state van het object veranderd.</p>

<p>@Override, @Deprecated zijn predefined, de andere hier aangegeven niet.</p>


        
    </li>
    
    <li>
        <h1 id="method-beschrijving">Method Beschrijving</h1>

<p>De blok commentaar boven een method die beschrijft hoe deze zal werken. De informele beschrijving komt eerst, gevolgd door een formele. De formele wordt beschreven in eerste orde logica en elke lijn begint met een verticale streep.</p>

<p>@post postcondities van de methode. Gebruik new. om aan te geven dat er gesproken wordt over de state <strong>na</strong> de beschrevn methode. Gebruik this. (mag ook weggelaten worden) om te spreken over de state <strong>voor</strong> de methode.</p>

<p>@return de postconditie van een niet-basic inspector. bv <code>if (ditMagNiet == false) result == true;</code></p>

<p>@effect beschrijving van het effect van een mutator in functie van andere mutators. Ook constructors kunnen hun effect beschrijven aan de hand van andere constructoren met <em>this(. . .)</em> of <em>super(. . .)</em>. Het resultaat van <strong>niet-basic</strong> inspectors kan beschreven worden aan de hand van andere inspectors.</p>

<p>In het algemeen mag de specificatie van publieke methodes enkel andere publieke methodes gebruiken. Private methods mogen wel andere private mothodes gebruiken in hun specificatie. Je kan echter private methodes annoteren met @Model, en dan mag je ze <strong>wel</strong> gebruiken in de specificatie van publieke methodes.</p>

<!--more-->

<h2 id="voorbeeld-van-enkele-constructors-uit-de-clock-oefening-uit-de-les">Voorbeeld van enkele constructors uit de clock oefening uit de les:</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm">* Initialize this new digital clock with given hours and</span>
<span class="cm">* given minutes.</span>
<span class="cm">*</span>
<span class="cm">* @param  hours</span>
<span class="cm">*         The hours for this new digital clock.</span>
<span class="cm">* @param  minutes</span>
<span class="cm">*         The minutes for this new digital clock.</span>
<span class="cm">* @post   The lowest possible value for the hours of this new</span>
<span class="cm">* 		   digital clock is equal to 0.</span>
<span class="cm">*       | new.getMinHours() == 0</span>
<span class="cm">* @post   The highest possible value for the hours of this new</span>
<span class="cm">* 		   digital clock is equal to 23.</span>
<span class="cm">*       | new.getMaxHours() == 23</span>
<span class="cm">* @post   If the given hours are in the range 0..23, the hours of</span>
<span class="cm">*         this new digital clock are equal to the given hours.</span>
<span class="cm">*         If the given hours exceed 23, the hours for this new</span>
<span class="cm">*         digital clock are equal to the given hours modulo 24.</span>
<span class="cm">*         If the given hours are negative, the hours for  this new</span>
<span class="cm">*         digital clock are equal to 0.</span>
<span class="cm">*       | if ( (hours &gt;= 0) &amp;&amp; (hours &lt;= 23) )</span>
<span class="cm">*       |   then new.getHours() == hours</span>
<span class="cm">*       | else if (hours &gt; 23)</span>
<span class="cm">*       |   then new.getHours() == (hours % 24)</span>
<span class="cm">*       | else if (hours &lt; 0)</span>
<span class="cm">*       |   then new.getHours() == 0</span>
<span class="cm">* @effect The given minutes are set as the minutes of this</span>
<span class="cm">*         new digital clock.</span>
<span class="cm">*       | setMinutes(minutes)</span>
<span class="cm">* @note   We cannot use the mutator setHours(int) in the specification,</span>
<span class="cm">*         because the range for the hours of this new digital clock is</span>
<span class="cm">*         0..0 upon entry to this constructor. We could introduce a more</span>
<span class="cm">*         general method setHours(hours,minHours,maxHours) to avoid</span>
<span class="cm">*         a duplication of the specification of setting the hours. At this</span>
<span class="cm">*         stage, we prefer not to do so to keep things simple at this</span>
<span class="cm">*         stage  of the course.</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="nf">DigitalClock</span><span class="o">(</span><span class="kt">int</span> <span class="n">hours</span><span class="o">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// At this point, we can invoke the mutator setHours, because the range</span>
    <span class="c1">// is known at this point.</span>
    <span class="n">setHours</span><span class="o">(</span><span class="n">hours</span><span class="o">);</span>
    <span class="n">setMinutes</span><span class="o">(</span><span class="n">minutes</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm">* Initialize this new digital clock with hours, minutes and seconds</span>
<span class="cm">* set to their lowest possible values.</span>
<span class="cm">*</span>
<span class="cm">* @effect This new digital clock is initialized with 0 as its</span>
<span class="cm">*         hours and with the lowest possible value for the minutes</span>
<span class="cm">*         as its minutes.</span>
<span class="cm">*       | this(0,DigitalClock.getMinMinutes())</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="nf">DigitalClock</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Java does not allow us to invoke instance methods in the</span>
    <span class="c1">// argument list. This seems reasonable, because at that time,</span>
    <span class="c1">// the object is not guaranteed to have a proper state.</span>
    <span class="c1">// We can therefore not write this.getMinMinutes() at this</span>
    <span class="c1">// point.</span>
    <span class="k">this</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">DigitalClock</span><span class="o">.</span><span class="na">getMinMinutes</span><span class="o">());</span>
<span class="o">}</span></code></pre></div>

<h2 id="voorbeeldjes-van-methodes">Voorbeeldjes van methodes:</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm">* Set the minutes of this digital clock to the given minutes.</span>
<span class="cm">*</span>
<span class="cm">* @param  minutes</span>
<span class="cm">*		   The new minutes for this digital clock.</span>
<span class="cm">* @post   If the given minutes are in the range of the minutes for all</span>
<span class="cm">* 		   digital clocks, the minutes of this digital clock are equal</span>
<span class="cm">* 		   to the given minutes.</span>
<span class="cm">*       | if ( (minutes &gt;= getMinMinutes()) &amp;&amp; (minutes &lt;= getMaxMinutes()) )</span>
<span class="cm">*       |   then new.getMinutes() == minutes</span>
<span class="cm">* @post   If the given minutes exceed the highest possible value for the</span>
<span class="cm">* 		   minutes of all digital clocks, or the given minutes are below</span>
<span class="cm">*         the lowest possible value for the minutes of all digital clocks,</span>
<span class="cm">*         the minutes of this digital clock remain unchanged.</span>
<span class="cm">*       | if ( (minutes &gt; getMaxMinutes() || (minutes &lt; getMinMinutes()) )</span>
<span class="cm">*       |   then new.getMinutes() = getMinutes()</span>
<span class="cm">* @note   The second postcondition is not really needed. Indeed, the</span>
<span class="cm">*         inertia axiom for specifications states that everything that is</span>
<span class="cm">*         not mentioned in the specification of a method, is left untouched.</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMinutes</span><span class="o">(</span><span class="kt">int</span> <span class="n">minutes</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">minutes</span> <span class="o">&gt;=</span> <span class="n">getMinMinutes</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">minutes</span> <span class="o">&lt;=</span> <span class="n">getMaxMinutes</span><span class="o">()))</span>
    <span class="k">this</span><span class="o">.</span><span class="na">minutes</span> <span class="o">=</span> <span class="n">minutes</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm">* Advance the time displayed by this digital clock with 1 minute.</span>
<span class="cm">*</span>
<span class="cm">* @effect If the minutes of this digital clock have not reached their highest</span>
<span class="cm">*		   possible value, the minutes currently displayed by this digital</span>
<span class="cm">*         clock incremented by 1 are set as the new minutes displayed</span>
<span class="cm">*         by this digital clock.</span>
<span class="cm">*       | if (getMinutes() &lt; getMaxMinutes())</span>
<span class="cm">*       |   then setMinutes(getMinutes()+1)</span>
<span class="cm">* @effect If the minutes of this digital clock have reached their highest</span>
<span class="cm">*		   possible value, the hours of this digital clock are advanced by</span>
<span class="cm">*		   1 and the minutes of this digital clock are reset to their</span>
<span class="cm">*         lowest possible value.</span>
<span class="cm">*       | if (getMinutes() == getMaxMinutes())</span>
<span class="cm">*       |   then (advanceHours() &amp;&amp; resetMinutes())</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">advanceMinutes</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getMinutes</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">getMaxMinutes</span><span class="o">())</span>
    <span class="n">setMinutes</span><span class="o">(</span><span class="n">getMinutes</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="n">resetMinutes</span><span class="o">();</span>
        <span class="n">advanceHours</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="basic-java">Basic Java</h1>

<h2 id="variables">Variables</h2>

<p>Instance variables: elk object heeft zijn eigen versie.</p>

<p>Statis variables: gedeeld door alle objecten van de zelfde class.</p>

<h2 id="encapsulation">Encapsulation</h2>

<p>Best practice: maak geen publieke variabelen, toon ze met een <em>getter</em> and maak het mogelijk ze te veranderen door een <em>setter</em>. Dit zorgt er voor dat je gemakkelijker later de achterliggende variabelen kan aanpassen als je dat wil: <em>better adaptable software</em>.</p>

<p>Een setter is een mutator, een getter een inspector. Voor immutable variabelen (krijgen de qualificatie final) is er geen setter, deze worden één keer een waarde geven bij het maken van het object.</p>


        
    </li>
    
    <li>
        <h1 id="nominal-programming">Nominal Programming</h1>

<p>Gebruik classe invarianten (worden aangegeven in de heading van een classe) en pre-condities.</p>

<p>Classe invarianten leggen restricties op de state van het object op en worden aangeven met @invar. Het zijn voorwaarden waar het object <strong>altijd</strong> aan moet voldoen. Methodes die het object in een inconsistente state brengen worden aangeduid met @Raw en deze moeten dus geen rekeningen houden met de classe invarianten. Worden zowel formeel (logica) als informeel beschreven bovenaan in de classe.</p>

<p>Precondities worden op de zelfde manier gebruikt als postcondities. Ze worden aangeven met @pre.</p>

<p>Precondities worden nagekeken door middel van een assert.</p>

<!--more-->

<h2 id="design-by-contract">Design by contract</h2>

<p>Gebruikers moeten verzekeren dat objecten doorgegeven aan een methode voldoen aan hun classe invarianten. Ook alle pre-condities moeten voldaan zijn.</p>

<p>De programmeur moet verzekeren dat objecten in een juiste state zijn na het uitvoeren van een methode, dat ze voldoen aan hun classe invarianten. Ook alle post-condities moeten voldaan zijn na een methode.</p>

<p>De programmeur kan bij het implementeren van een methode er van uit gaan dat de precondities en classe invarianten voldaan zijn.</p>

<h2 id="voorbeeldje-van-invarianten-uit-de-les">Voorbeeldje van invarianten uit de les:</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm">* A class of tanks for storing oil, involving a capacity and a content.</span>
<span class="cm">*</span>
<span class="cm">* @invar  The capacity of each oil tank must be a valid capacity for an</span>
<span class="cm">*         oil tank.</span>
<span class="cm">*         | isValidCapacity(getCapacity())</span>
<span class="cm">* @invar  The contents of each oil tank must be a valid contents for an</span>
<span class="cm">*         oil tank in view of its capacity.</span>
<span class="cm">*         | isValidContents(getContents(),getCapacity())</span>
<span class="cm">*</span>
<span class="cm">* @version  2.1</span>
<span class="cm">* @author   Eric Steegmans</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OilTank</span> <span class="o">{</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="o">}</span></code></pre></div>

<h2 id="voorbeeldje-van-preconditie-en-assert">Voorbeeldje van preconditie en assert:</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm">* Fill this oil tank with the given amount of oil.</span>
<span class="cm">*</span>
<span class="cm">* @param  amount</span>
<span class="cm">*         The amount to be added to this oil tank.</span>
<span class="cm">* @pre    The given amount must be positive.</span>
<span class="cm">*       | amount &gt; 0</span>
<span class="cm">* @effect The contents of this oil tank is set to its current contents</span>
<span class="cm">*         incremented with the given amount of oil.</span>
<span class="cm">*       | setContents(getContents() + amount)</span>
<span class="cm">* @note   Because we use the method setContents in the specification,</span>
<span class="cm">*         this method has another precondition, namely</span>
<span class="cm">*            isValidContents(getContents()+amount,getCapacity())</span>
<span class="cm">*         If the sum of the contents and the amount would overflow,</span>
<span class="cm">*         the resulting value is guaranteed to be negative, and</span>
<span class="cm">*         will therefore not be accepted.</span>
<span class="cm">* @note   Because this is not a &#39;raw&#39; method, this oil tank must</span>
<span class="cm">* 		   satisfy its class invariants upon entry to this method.</span>
<span class="cm">* 		   Upon exit, it is easy to see that this oil tank then still</span>
<span class="cm">* 		   satisfies its class invariants.</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">fill</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">assert</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">setContents</span><span class="o">(</span><span class="n">getContents</span><span class="o">()</span> <span class="o">+</span> <span class="n">amount</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="testing">Testing</h1>

<p>Test elke mogelijke <em>verschillende</em> case voor parameters in een method.</p>

<p>Geen tests voor basic inspectors (ze hebben geen specificatie) en geen test voor private methods (zijn niet accessable buiten de classe). Ook geen tests met parameters die niet voldoen aan de precondities.</p>

<h2 id="junit4">JUnit4</h2>

<p>Test methods geef je aan met een @Test annotatie. Een method met @Before word voor elke test uitgevoerd, @After na <em>elke test</em>. Ook @BeforeClass en @AfterClass bestaan, deze worden een (1) keer bij het begin of einde van <em>alle tests</em> uitgevoerd.</p>

<p>(Er moet ook getest worden of exceptions op de aangegeven momenten gesmeten worden, meer over exceptions later.)</p>

<!--more-->

<h2 id="voorbeeldje-test-classe-van-oiltank-oefening-uit-de-les">Voorbeeldje test classe van OilTank oefening uit de les:</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">Assert</span><span class="o">.*;</span>

<span class="kn">import</span> <span class="nn">org.junit.Before</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.BeforeClass</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OilTankTests</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">OilTank</span> <span class="n">emptyTank</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">    * Set up n immutable test fixture.</span>
<span class="cm">    *</span>
<span class="cm">    * @post   The variable emptyTank references a new</span>
<span class="cm">    *         oil tank that is empty.</span>
<span class="cm">    */</span>
    <span class="nd">@BeforeClass</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setUpBeforeClass</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">emptyTank</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">OilTank</span><span class="o">(</span><span class="mi">2000</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">OilTank</span> <span class="n">tankCap1000Cont200</span><span class="o">,</span> <span class="n">tankCont500</span><span class="o">,</span> <span class="n">fullTank</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">    * Set up a mutable test fixture.</span>
<span class="cm">    *</span>
<span class="cm">    * @post   The variable tankCap1000Cont200 references a new</span>
<span class="cm">    *         oil tank with capacity 1000 and contents 200.</span>
<span class="cm">    * @post   The variable tankCont500 references a new</span>
<span class="cm">    *         oil tank with contents 500 and a sufficiently</span>
<span class="cm">    *         high capacity.</span>
<span class="cm">    * @post   The variable fullTank references a new</span>
<span class="cm">    *         oil tank that is completely filled.</span>
<span class="cm">    */</span>
    <span class="nd">@Before</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">tankCap1000Cont200</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">OilTank</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="n">tankCont500</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">OilTank</span><span class="o">(</span><span class="mi">3000</span><span class="o">,</span> <span class="mi">500</span><span class="o">);</span>
        <span class="n">fullTank</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">OilTank</span><span class="o">(</span><span class="mi">2000</span><span class="o">,</span> <span class="mi">2000</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">extendedConstructor_SingleCase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">OilTank</span> <span class="n">newTank</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">OilTank</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">300</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">newTank</span><span class="o">.</span><span class="na">getCapacity</span><span class="o">());</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">300</span><span class="o">,</span> <span class="n">newTank</span><span class="o">.</span><span class="na">getContents</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">isValidCapacity_TrueCase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertTrue</span><span class="o">(</span><span class="n">OilTank</span><span class="o">.</span><span class="na">isValidCapacity</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="c1">//assertFalse, assertNull en meer bestaan ook in JUnit4</span>
    <span class="o">}</span>

    <span class="c1">// en nog veel veel meer</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="more-java">More Java</h1>

<h2 id="variabel-aantal-argumenten">Variabel aantal argumenten</h2>

<p>bv: <code>void method(int... args)</code></p>

<p>Deze worden intern gewoon een array van ints, en kunnen zo ook gebruikt worden met bijvoorbeeld het enhance-for statement:</p>

<h2 id="enhanced-for">Enhanced for</h2>

<p>bv: <code>for (Type variable: collection)</code></p>

<p>Gebaseerd op iterators en werkt op arrays.</p>


        
    </li>
    
    <li>
        <h1 id="defensief-programmeren">Defensief Programmeren</h1>

<p>Exceptions! Gooi exceptions bij onbruikbare parameters. Alternatief voor <em>totaal programmeren</em> (afgehanheld in de methode zef) of <em>nominal programming</em> (pre-condities).</p>

<p>Als er exceptions gegooid worden moeten deze bij de declaratie van de methode aangegeven worden: <code>void method() throws Exception1, Exception2</code>. Errors (stack overflow, out of memory, . . .) moeten hier niet aangegeven worden, <strong>alle</strong> andere exceptions wel.</p>

<p>De reden waarom een bepaalde exception gesmeten word moet ook aangegeven worden in de heading van een classe: @throws of @exception. Liefst zowel formeel als informeel.</p>

<!--more-->

<h2 id="checked-vs-unchecked">Checked vs Unchecked</h2>

<p>Checked exceptions <strong>moeten</strong> ge-catch-ed worden. De compiler zal na kijken of er een try-catch rond methodes staat die checked exceptions smijten. Zeer lastig en niet zo vaak gebruikt.</p>

<p>Unchecked spreekt dan voor zich, hier zal de compiler niet lastig doen als er geen try-catch rond staat.</p>

<h2 id="try-catch-finally">Try-Catch-Finally</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">try</span> <span class="o">{</span>
    <span class="o">...</span> <span class="c1">//code die mogelijk een exception smijt</span>
<span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="n">MijnException1</span> <span class="o">|</span> <span class="n">MijnException2</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span> <span class="c1">//code die deze twee soorten exceptions af handels</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="k">catch</span> <span class="o">(</span><span class="n">MijnException100</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span> <span class="c1">//code die MijnException100 af handeld</span>
<span class="o">}</span>
<span class="k">finally</span> <span class="o">{</span>
    <span class="o">...</span> <span class="c1">//word sowieso opgeroepen, of er nu een catch nodig was of niet.</span>
<span class="o">}</span></code></pre></div>

<h2 id="voorbeeld-van-eigen-exception-class">Voorbeeld van eigen exception class:</h2>

<p>Hier is eigenlijk niets speciaals aan, bijna het zelfde als een normale classe.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">be.kuleuven.cs.som.annotate.*</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">* A class for signaling illegal denominators for rational numbers.</span>
<span class="cm">*</span>
<span class="cm">* @note     In this session, we use checked exceptions to illustrate</span>
<span class="cm">*           the problems they bring in Java. Starting from the next</span>
<span class="cm">*           session, we will only work with unchecked exceptions.</span>
<span class="cm">* @version  2.0</span>
<span class="cm">* @author   Eric Steegmans</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IllegalDenominatorException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">    * Initialize this new illegal denominator exception with given value.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  value</span>
<span class="cm">    *         The value for this new illegal denominator exception.</span>
<span class="cm">    * @post   The value of this new illegal denominator exception is equal</span>
<span class="cm">    *         to the given value.</span>
<span class="cm">    *       | new.getValue() == value</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="nf">IllegalDenominatorException</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Return the value registered for this illegal denominator exception.</span>
<span class="cm">    */</span>
    <span class="nd">@Basic</span> <span class="nd">@Immutable</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Variable registering the value involved in this illegal denominator</span>
<span class="cm">    * exception.</span>
<span class="cm">    */</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">value</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">    * The Java API strongly recommends to explicitly define a version</span>
<span class="cm">    * number for classes that implement the interface Serializable.</span>
<span class="cm">    * At this stage, that aspect is of no concern to us.</span>
<span class="cm">    */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">2003001L</span><span class="o">;</span>

<span class="o">}</span></code></pre></div>

<h2 id="voorbeeld-van-throws">Voorbeeld van throws</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm">*  Return a rational number obtained by multiplying this rational</span>
<span class="cm">*  number with the given integer number.</span>
<span class="cm">*</span>
<span class="cm">* @param  factor</span>
<span class="cm">*         The integer number to multiply with.</span>
<span class="cm">* @return The resulting rational number has the same value as a rational number</span>
<span class="cm">*         whose denominator is equal to the denominator of this rational</span>
<span class="cm">*         number in normalized form, and whose numerator is equal to the</span>
<span class="cm">*         numerator of this rational number in normalized form multiplied</span>
<span class="cm">*         with the given factor divided by the greatest common divisor of</span>
<span class="cm">*         the absolute value of that factor and the denominator of this</span>
<span class="cm">*         rational number in normalized form.</span>
<span class="cm">*        | let</span>
<span class="cm">*        |   reducedFactor = factor / ExtMath.gcd</span>
<span class="cm">*        |     (Math.abs(factor),this.normalize().getDenominator())</span>
<span class="cm">*        | in</span>
<span class="cm">*        |   result.hasSameValueAs(</span>
<span class="cm">*        |     new Rational(</span>
<span class="cm">*        |       this.normalize().getNumerator()*reducedFactor,</span>
<span class="cm">*        |       this.normalize().getDenominator()))</span>
<span class="cm">* @throws TimesOverflowException</span>
<span class="cm">*         The product of the numerator of this rational number in</span>
<span class="cm">*         normalized form with the given factor divided by the greatest</span>
<span class="cm">*         common divisor of the absolute value of that factor and the</span>
<span class="cm">*         denominator of this rational number in normalized form is</span>
<span class="cm">*         outside the range of the type long.</span>
<span class="cm">*       | let</span>
<span class="cm">*       |   reducedFactor = factor / ExtMath.gcd</span>
<span class="cm">*       |     (Math.abs(factor),this.normalize().getDenominator())</span>
<span class="cm">*       | in</span>
<span class="cm">*       |   ! ExtMath.areMulipliable</span>
<span class="cm">*       |     (this.normalize().getNumerator(),reducedFactor)</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="n">Rational</span> <span class="nf">times</span><span class="o">(</span><span class="kt">long</span> <span class="n">factor</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">TimesOverflowException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// In a first attempt, we simply try to multiply the numerator</span>
            <span class="c1">// of this rational number with the given factor. This yields</span>
            <span class="c1">// efficient computations for small rational numbers and</span>
            <span class="c1">// factors.</span>
            <span class="kt">long</span> <span class="n">newNumerator</span> <span class="o">=</span> <span class="n">ExtMath</span><span class="o">.</span><span class="na">times</span><span class="o">(</span><span class="n">getNumerator</span><span class="o">(),</span> <span class="n">factor</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Rational</span><span class="o">(</span><span class="n">newNumerator</span><span class="o">,</span> <span class="n">getDenominator</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">TimesOverflowException</span> <span class="n">exc</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">assert</span> <span class="o">!</span><span class="n">ExtMath</span><span class="o">.</span><span class="na">areMultipliable</span><span class="o">(</span><span class="n">getNumerator</span><span class="o">(),</span> <span class="n">factor</span><span class="o">);</span>
            <span class="c1">// If we can reduce this rational number by normalization,</span>
            <span class="c1">// we invoke the method on the normalized version of this</span>
            <span class="c1">// rational number.</span>
            <span class="n">Rational</span> <span class="n">thisNormalized</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">normalize</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">thisNormalized</span><span class="o">.</span><span class="na">getNumerator</span><span class="o">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">.</span><span class="na">getNumerator</span><span class="o">())</span>
            <span class="k">return</span> <span class="nf">normalize</span><span class="o">().</span><span class="na">times</span><span class="o">(</span><span class="n">factor</span><span class="o">);</span>
            <span class="c1">// If the given factor and the denominator of this rational</span>
            <span class="c1">// number (which must be a normalized rational number at this</span>
            <span class="c1">// point), have some factor in common, we invoke the method again</span>
            <span class="c1">// reversing the roles of the factor and the numerator of this</span>
            <span class="c1">// rational number.</span>
            <span class="n">Rational</span> <span class="n">toReduce</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Rational</span><span class="o">(</span><span class="n">factor</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getDenominator</span><span class="o">())</span>
            <span class="o">.</span><span class="na">normalize</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">toReduce</span><span class="o">.</span><span class="na">getNumerator</span><span class="o">()</span> <span class="o">!=</span> <span class="n">factor</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">toReduce</span><span class="o">.</span><span class="na">times</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getNumerator</span><span class="o">());</span>
            <span class="k">throw</span> <span class="n">exc</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalDenominatorException</span> <span class="n">exc</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="class-diagrams">Class Diagrams</h1>

<p><img src="/part2/images/uml_marriage.png" alt="marriage" /></p>

<p>Classen worden voorgesteld als rechthoeken met 3 onderdelen. Eerst de naam van de classe, dan de attributes (of properties) en als laatste de methods. Attributes krijgen een achterliggende variabele, met eventueel een getter en setter.</p>

<p>Associaties worden aangegeven met een lijntje tussen classes. Er kan een bijhorende attribute aangegeven worden bij het lijntje (-spouse op de afbeelding), als ook een naam voor de associatie (marriage). Verder kan je de multipliciteit aangeven (bv 0..1, 0.., 1..).</p>

<p>Belangrijk: Als je bi-directionele assiciaties hebt moeten mutators, destructors en constructors de classe invarianten respecteren in <strong>beide</strong> richtingen.</p>

<!--more-->

<h2 id="bi-directional">Bi-directional</h2>

<p>Bi-directionele associaties moeten een classe-invariant hebben die deze af dwingt. Meestal zal er gebruik gemaakt worden van <code>canHaveAsSomething(T)</code>. De consistentie wordt gechecked in the inspector <code>hasProperSomething()</code></p>

<h2 id="voorbeeldje">Voorbeeldje</h2>

<p>De person.java classe gemaakt in de les. Er zijn enkele stukken uit weggehaald met wat minder interessante delen.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">be.kuleuven.cs.som.annotate.*</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">* A class of persons involving a gender and a</span>
<span class="cm">* marital partner.</span>
<span class="cm">*</span>
<span class="cm">* @invar   The gender of each person must be a valid gender</span>
<span class="cm">*          for a person.</span>
<span class="cm">*          isValidGender(getGender())</span>
<span class="cm">* @invar   Each person must have a proper spouse.</span>
<span class="cm">*        | hasProperSpouse()</span>
<span class="cm">*</span>
<span class="cm">* @version  2.0</span>
<span class="cm">* @author   Eric Steegmans</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">    * Initialize this new person with given gender and given partner.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  gender</span>
<span class="cm">    *         The gender for this new person.</span>
<span class="cm">    * @param  partner</span>
<span class="cm">    *         The partner for this new person.</span>
<span class="cm">    * @post   The gender of this new person is the same as the given gender.</span>
<span class="cm">    *       | new.getGender() == gender</span>
<span class="cm">    * @post   This new person references the given partner as its spouse.</span>
<span class="cm">    *       | new.getSpouse() == partner</span>
<span class="cm">    * @post   If the given partner references a true person, that partner</span>
<span class="cm">    *         references this new person as its spouse.</span>
<span class="cm">    *       | if (partner != null)</span>
<span class="cm">    *       |   then (new partner).getSpouse() == this</span>
<span class="cm">    * @throws IllegalArgumentException</span>
<span class="cm">    *         The given gender is not a valid gender for a person.</span>
<span class="cm">    *       | ! isValidGender(gender)</span>
<span class="cm">    * @throws IllegalPartnerException</span>
<span class="cm">    *         This new person cannot have the given partner as its spouse</span>
<span class="cm">    *         in view of the given gender.</span>
<span class="cm">    *       | ! canHaveAsSpouse(partner,gender)</span>
<span class="cm">    * @throws IllegalPartnerException</span>
<span class="cm">    *         The given partner is effective and already married.</span>
<span class="cm">    *       | (partner != null) &amp;&amp; partner.isMarried()</span>
<span class="cm">    * @note   In the specification of this constructor, we cannot use the</span>
<span class="cm">    *         mutator &#39;marry&#39;. Indeed, upon entry to the constructor, the</span>
<span class="cm">    *         gender of this new person is still null, meaning that that</span>
<span class="cm">    *         new person does not satisfy its class invariants. Because</span>
<span class="cm">    *         the method &#39;marry&#39; is not a raw method, we cannot invoke it</span>
<span class="cm">    *         against the new person.</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">Gender</span> <span class="n">gender</span><span class="o">,</span> <span class="n">Person</span> <span class="n">partner</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">IllegalArgumentException</span><span class="o">,</span> <span class="n">IllegalPartnerException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isValidGender</span><span class="o">(</span><span class="n">gender</span><span class="o">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Improper gender!&quot;</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">partner</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">marry</span><span class="o">(</span><span class="n">partner</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Return the spouse of this person.</span>
<span class="cm">    *    A null reference is returned if this person is not married.</span>
<span class="cm">    */</span>
    <span class="nd">@Basic</span> <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="n">Person</span> <span class="nf">getSpouse</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">spouse</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this person can have the other person as its spouse</span>
<span class="cm">    * in view of the given gender.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  other</span>
<span class="cm">    *         The other person to check.</span>
<span class="cm">    * @param  gender</span>
<span class="cm">    *         The gender to be assumed for this person.</span>
<span class="cm">    * @return True if the other person is not effective.</span>
<span class="cm">    *       | if (other == null)</span>
<span class="cm">    *       |   then result == true</span>
<span class="cm">    *         Otherwise, false if this person or the other person</span>
<span class="cm">    *         is terminated.</span>
<span class="cm">    *       | else if ( this.isTerminated() || other.isTerminated() )</span>
<span class="cm">    *       |   then result == false</span>
<span class="cm">    *         Otherwise, true if and only if the given gender is a valid</span>
<span class="cm">    *         gender for a person and differs from the gender of the</span>
<span class="cm">    *         other person.</span>
<span class="cm">    *       | else</span>
<span class="cm">    *       |   result ==</span>
<span class="cm">    *       |     isValidGender(gender) &amp;&amp;</span>
<span class="cm">    *       |     (gender != other.getGender())</span>
<span class="cm">    * @note   We must add the gender as an extra argument to this method,</span>
<span class="cm">    *         because we need the method in the constructor at a time</span>
<span class="cm">    *         the gender of the new person is not yet registered.</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canHaveAsSpouse</span><span class="o">(</span><span class="nd">@Raw</span> <span class="n">Person</span> <span class="n">other</span><span class="o">,</span> <span class="n">Gender</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">other</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">other</span><span class="o">.</span><span class="na">isTerminated</span><span class="o">())</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isTerminated</span><span class="o">()))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">else</span>
        <span class="k">return</span> <span class="nf">isValidGender</span><span class="o">(</span><span class="n">gender</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">gender</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="na">getGender</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this person has a proper spouse.</span>
<span class="cm">    *</span>
<span class="cm">    * @return True if and only if this person can have its spouse</span>
<span class="cm">    *         as its spouse in view of its current gender, and if</span>
<span class="cm">    *         that spouse, if it is effective, in turn references</span>
<span class="cm">    *         this person as its spouse.</span>
<span class="cm">    *       | result ==</span>
<span class="cm">    *       |   canHaveAsSpouse(getSpouse(),getGender()) &amp;&amp;</span>
<span class="cm">    *       |   ( (getSpouse() == null) ||</span>
<span class="cm">    *       |     (getSpouse().getSpouse() == this) )</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasProperSpouse</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">canHaveAsSpouse</span><span class="o">(</span><span class="n">getSpouse</span><span class="o">(),</span> <span class="n">getGender</span><span class="o">())</span>
        <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">getSpouse</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">getSpouse</span><span class="o">().</span><span class="na">getSpouse</span><span class="o">()</span> <span class="o">==</span> <span class="k">this</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this person is married.</span>
<span class="cm">    *</span>
<span class="cm">    * @return True if this person references an effective spouse;</span>
<span class="cm">    *         false otherwise.</span>
<span class="cm">    *       | result == (getSpouse() != null)</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMarried</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getSpouse</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Register a marriage between this person and the given partner.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  partner</span>
<span class="cm">    *         The new spouse for this person.</span>
<span class="cm">    * @post   The given partner is registered as the spouse of this person.</span>
<span class="cm">    *       | new.getSpouse() == partner</span>
<span class="cm">    * @post   This person is registered as the spouse of the given partner.</span>
<span class="cm">    *       | (new partner).getSpouse() == this</span>
<span class="cm">    * @throws IllegalPartnerException</span>
<span class="cm">    *         The given partner is not effective, or this person cannot</span>
<span class="cm">    *         have the given partner as its spouse in view of its current</span>
<span class="cm">    *         gender.</span>
<span class="cm">    *       | (partner == null) ||</span>
<span class="cm">    *       | (! this.canHaveAsSpouse(partner,this.getGender()))</span>
<span class="cm">    * @throws IllegalStateException</span>
<span class="cm">    *         This person is already married, or the given partner is an</span>
<span class="cm">    *         effective, married person.</span>
<span class="cm">    *       | this.isMarried() ||</span>
<span class="cm">    *       | ( (partner != null) &amp;&amp; partner.isMarried())</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">marry</span><span class="o">(</span><span class="n">Person</span> <span class="n">partner</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IllegalPartnerException</span><span class="o">,</span>
    <span class="n">IllegalStateException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">partner</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">(!</span><span class="n">canHaveAsSpouse</span><span class="o">(</span><span class="n">partner</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">getGender</span><span class="o">())))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalPartnerException</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">partner</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isMarried</span><span class="o">()</span> <span class="o">||</span> <span class="n">partner</span><span class="o">.</span><span class="na">isMarried</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;Married persons cannot marry&quot;</span><span class="o">);</span>
        <span class="n">setSpouse</span><span class="o">(</span><span class="n">partner</span><span class="o">);</span>
        <span class="n">partner</span><span class="o">.</span><span class="na">setSpouse</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Register a divorce between this person and its partner, if any.</span>
<span class="cm">    *</span>
<span class="cm">    * @post   This person is no longer married.</span>
<span class="cm">    *	     | ! new.isMarried()</span>
<span class="cm">    * @post   The former spouse of this person, if any, is no longer</span>
<span class="cm">    *		   married.</span>
<span class="cm">    *       | if (this.isMarried())</span>
<span class="cm">    *       |   then ! (new (this.getSpouse())).isMarried())</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">divorce</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">getSpouse</span><span class="o">().</span><span class="na">setSpouse</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">setSpouse</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NullPointerException</span> <span class="n">exc</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">assert</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">isMarried</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Register the given person as the spouse of this person.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  person</span>
<span class="cm">    *         The person to be registered as the spouse of this person.</span>
<span class="cm">    * @pre    This person must be able to have the given person as</span>
<span class="cm">    *         its spouse, in view of its current gender.</span>
<span class="cm">    *       | canHaveAsSpouse(person,getGender())</span>
<span class="cm">    * @post   The spouse of this person is the same as the given person.</span>
<span class="cm">    *       | new.getSpouse() == person</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setSpouse</span><span class="o">(</span><span class="nd">@Raw</span> <span class="n">Person</span> <span class="n">person</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="nf">canHaveAsSpouse</span><span class="o">(</span><span class="n">person</span><span class="o">,</span> <span class="n">getGender</span><span class="o">());</span>
        <span class="k">this</span><span class="o">.</span><span class="na">spouse</span> <span class="o">=</span> <span class="n">person</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Variable referencing the spouse of this person.</span>
<span class="cm">    */</span>
    <span class="kd">private</span> <span class="n">Person</span> <span class="n">spouse</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="enumerations">Enumerations</h1>

<p>Enumerations definieerd een vast aantal benoemde objecten. Elk object kan eigen variabelen en methodes hebben, en ze kunnen er ook delen.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">enum</span> <span class="n">EnumerationType</span> <span class="o">{</span>

    <span class="n">ELEMENT1</span> <span class="o">{</span> <span class="cm">/* Methods and variables for ELEMENT1 */</span> <span class="o">},</span>
    <span class="o">...</span>
    <span class="n">ELEMENTn</span> <span class="o">{</span> <span class="cm">/* Methods and variables for ELEMENTn */</span> <span class="o">};</span>

    <span class="cm">/* Methods and variables common to all elements */</span>
<span class="o">}</span></code></pre></div>

<!--more-->

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Gender</span> <span class="o">{</span>

    <span class="n">MALE</span> <span class="o">{</span>

        <span class="cm">/**</span>
<span class="cm">        * Return the symbol representing the male gender.</span>
<span class="cm">        *</span>
<span class="cm">        * @return  The symbol with unicode U+2642.</span>
<span class="cm">        *        | result == &#39;\u2642&#39;</span>
<span class="cm">        */</span>
        <span class="kd">public</span> <span class="kt">char</span> <span class="nf">getSymbol</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="sc">&#39;\u2642&#39;</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">},</span>

    <span class="n">FEMALE</span> <span class="o">{</span>

        <span class="cm">/**</span>
<span class="cm">        * Return the symbol representing the female gender.</span>
<span class="cm">        *</span>
<span class="cm">        * @return  The symbol with unicode U+2640.</span>
<span class="cm">        *        | result == &#39;\u2640&#39;</span>
<span class="cm">        */</span>
        <span class="kd">public</span> <span class="kt">char</span> <span class="nf">getSymbol</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="sc">&#39;\u2640&#39;</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="cm">/**</span>
<span class="cm">    * Return the symbol representing this gender.</span>
<span class="cm">    *</span>
<span class="cm">    * @note    An enumeration may define abstract methods (i.e.</span>
<span class="cm">    *          methods without a body). Each element of the</span>
<span class="cm">    *          enumeration must then supply its own body.</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">char</span> <span class="nf">getSymbol</span><span class="o">();</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="some-more-java">Some More Java</h1>

<h2 id="garbage-collector">Garbage Collector</h2>

<p>Draait op de achtergrond (eigen thread) en kuist alle onbereikbare objecten op. Kan expliciet aangeroepen worden met <code>System.gc()</code> maar zelfs dat verzekerd niet dat hij zal beginnen.</p>

<p>Een object kan <code>finalize()</code> op zichzelf aanroepen om te vragen op gekuist te worden. De GC zal echter niet altijd luisteren, en doet het alleen als het object niet meer bereikbaar is.</p>

<h2 id="destructor">Destructor</h2>

<p>Een destructor method krijgt de naam <code>terminate</code>, er mag <strong>maximum</strong> een (1) destructor per classe zijn. Een destructor mag exceptions smijten.</p>

<p>Een classe kan ook een (1) inspector implementeren <code>boolean isTerminated()</code>. Als het object geterminate is moet het echter nog steeds voldoen aan de classe invarianten, en die invarianten of de methodes moeten hier rekening mee houden. Mutators moeten er ook rekening mee houden dat een meegegeven object terminated kan zijn.</p>

<!--more-->

<h2 id="een-voorbeeldje-van-de-terminate-functionaliteit">Een voorbeeldje van de terminate functionaliteit</h2>

<p>Deze classe is weer een versie van de Person classe met wat stuff uit gesmeten die hier niet van belang is. Het toont de terminate dingen en een functie die rekening houdt met deze terminate.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">    * Terminate this person, breaking the marriage in which that person</span>
<span class="cm">    * might be involved.</span>
<span class="cm">    *</span>
<span class="cm">    * @post    his person is terminated.</span>
<span class="cm">    *       | new.isTerminated()</span>
<span class="cm">    * @effect This person is divorced from its spouse, if any.</span>
<span class="cm">    *       | this.divorce()</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">terminate</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">divorce</span><span class="o">();</span>
        <span class="c1">// We feel no need to introduce a setter for &quot;isTerminated&quot;. It is</span>
        <span class="c1">// only used at this point, because it should not be possible to</span>
        <span class="c1">// bring an object back to live.</span>
        <span class="k">this</span><span class="o">.</span><span class="na">isTerminated</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Return a boolean indicating whether or not this person</span>
<span class="cm">    * is terminated.</span>
<span class="cm">    */</span>
    <span class="nd">@Basic</span> <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isTerminated</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">isTerminated</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Variable registering whether this person is terminated.</span>
<span class="cm">    */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isTerminated</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this person can have the other person as its spouse</span>
<span class="cm">    * in view of the given gender.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  other</span>
<span class="cm">    *         The other person to check.</span>
<span class="cm">    * @param  gender</span>
<span class="cm">    *         The gender to be assumed for this person.</span>
<span class="cm">    * @return True if the other person is not effective.</span>
<span class="cm">    *       | if (other == null)</span>
<span class="cm">    *       |   then result == true</span>
<span class="cm">    *         Otherwise, false if this person or the other person</span>
<span class="cm">    *         is terminated.</span>
<span class="cm">    *       | else if ( this.isTerminated() || other.isTerminated() )</span>
<span class="cm">    *       |   then result == false</span>
<span class="cm">    *         Otherwise, true if and only if the given gender is a valid</span>
<span class="cm">    *         gender for a person and differs from the gender of the</span>
<span class="cm">    *         other person.</span>
<span class="cm">    *       | else</span>
<span class="cm">    *       |   result ==</span>
<span class="cm">    *       |     isValidGender(gender) &amp;&amp;</span>
<span class="cm">    *       |     (gender != other.getGender())</span>
<span class="cm">    * @note   We must add the gender as an extra argument to this method,</span>
<span class="cm">    *         because we need the method in the constructor at a time</span>
<span class="cm">    *         the gender of the new person is not yet registered.</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canHaveAsSpouse</span><span class="o">(</span><span class="nd">@Raw</span> <span class="n">Person</span> <span class="n">other</span><span class="o">,</span> <span class="n">Gender</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">other</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">other</span><span class="o">.</span><span class="na">isTerminated</span><span class="o">())</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isTerminated</span><span class="o">()))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nf">isValidGender</span><span class="o">(</span><span class="n">gender</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">gender</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="na">getGender</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="c1">// ...</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="packages">Packages</h1>

<p>Packages kunnen gebruikt worden om classes die samen horen te groeperen. Alle files met een classe die behoort tot een bepaalde package beginnen met <code>package packageName;</code>. Je kan ook sub-packages en sub-sub-packages (enz) gebruiken: <code>package pacName.subPac.subSubPac</code>. De folder-structuur moet overeen komen met deze packages.</p>

<p>In packages moeten classes verschillende namen hebben, er kunnen echter wel classen met de zelfde naam in verschillende packages zitten. Een classe in een packge heeft eigenlijk een langere <em>qualified name</em>. De classe <code>myClass</code> in de package <code>myPackage</code> heet dus eigenlijk <code>myPackage.myClass</code>.</p>

<p>Om classen uit <strong>andere</strong> packages te gebruiken moet je een <code>import packageName.className</code> statement bovenaan de file zetten. Je kan ook <code>import packageName.*</code> gebruiken om alle classen uit een package te kunnen gebruiken.</p>


        
    </li>
    
    <li>
        <h1 id="unrestricted-connectivity">Unrestricted Connectivity</h1>

<p><img src="/part2/images/uml_banking.jpg" alt="banking" /></p>

<p>Om multiple-assiciation te hebben gebruiken we een lijst structuur. Met bijhorende <code>getXAt(i)</code>, <code>addAsXAt(x,i)</code>, <code>removeAsXAt(i)</code>. Alternatief kan je ook <code>addAsX(x)</code> en <code>removeAsX(x)</code> gebruiken als ze ongeordend zijn. Daar komen dan nog checkers bij <code>canHaveAsXAt(x,i)</code> of <code>canHaveAsX(x)</code>. En introduceer een class invariant <code>hasProperXs()</code> (meervoud).</p>

<p>Om een of andere reden moet je dit 1-based doen, en niet 0-based. Dus als je de getter implementeerd doe je:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Basic</span>
<span class="nd">@Raw</span>
<span class="kd">public</span> <span class="n">Purchase</span> <span class="nf">getPurchaseAt</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IndexOutOfBoundsException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">purchases</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>

<!--more-->

<h2 id="voorbeeldje-van-alle-nodige-methodes-voor-unrestricted-connectivity">Voorbeeldje van alle nodige methodes voor unrestricted connectivity</h2>

<ul>
  <li>getGranteeAt(i)</li>
  <li>getNbGrantees()</li>
  <li>addAsGranteeAt(person,i)</li>
  <li>addAsGrantee(person)</li>
  <li>removeAsGranteeAt(i)</li>
  <li>removeAsGrantee(person)</li>
  <li>canHaveAsGranteeAt(person,i)</li>
  <li>hasProperGrantees()</li>
</ul>

<p>of ongeordend:</p>

<ul>
  <li>hasAsSavingsAccount(savings)</li>
  <li>addAsSavingsAccount(savings)</li>
  <li>removeAsSavingsAccount(savings)</li>
  <li>canHaveAsSavingsAccount(savings)</li>
  <li>hasProperSavingsAccounts()</li>
</ul>

<h2 id="voorbeeld-van-een-classe">Voorbeeld van een classe</h2>

<p>Een deel van de class is weggehaald. Enkel de delen die de meerdere-associatie tonen zijn gebleven.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">banking</span><span class="o">.</span><span class="na">shares</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">banking.money.MoneyAmount</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">banking.shares.Purchase</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">be.kuleuven.cs.som.annotate.*</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm">* A class a shares involving a code, a value and a set of</span>
<span class="cm">* purchases in which they are involved.</span>
<span class="cm">*</span>
<span class="cm">* @invar   Each share must have a valid code.</span>
<span class="cm">*        | canHaveAsCode(getCode())</span>
<span class="cm">* @invar   The value of each share must be a valid value for any share.</span>
<span class="cm">*        | isValidValue(getValue())</span>
<span class="cm">* @invar   Each share must have proper purchases.</span>
<span class="cm">*        | hasProperPurchases()</span>
<span class="cm">*</span>
<span class="cm">* @version 2.0</span>
<span class="cm">* @author  Eric Steegmans</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Share</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">    * Return the purchase associated with this share at the</span>
<span class="cm">    * given index.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  index</span>
<span class="cm">    *         The index of the purchase to return.</span>
<span class="cm">    * @throws IndexOutOfBoundsException</span>
<span class="cm">    *         The given index is not positive or it exceeds the</span>
<span class="cm">    *         number of purchases for this share.</span>
<span class="cm">    *       | (index &lt; 1) || (index &gt; getNbPurchases())</span>
<span class="cm">    */</span>
    <span class="nd">@Basic</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="n">Purchase</span> <span class="nf">getPurchaseAt</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IndexOutOfBoundsException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">purchases</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Return the number of purchases associated with this share.</span>
<span class="cm">    */</span>
    <span class="nd">@Basic</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNbPurchases</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">purchases</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this share can have the given purchase</span>
<span class="cm">    * as one of its purchases.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  purchase</span>
<span class="cm">    *         The purchase to check.</span>
<span class="cm">    * @return True if and only if the given purchase is effective</span>
<span class="cm">    *         and that purchase can have this share as its share.</span>
<span class="cm">    *       | result ==</span>
<span class="cm">    *       |   (purchase != null) &amp;&amp;</span>
<span class="cm">    *       |   purchase.canHaveAsShare(this)</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canHaveAsPurchase</span><span class="o">(</span><span class="n">Purchase</span> <span class="n">purchase</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">purchase</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">purchase</span><span class="o">.</span><span class="na">canHaveAsShare</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this share can have the given purchase</span>
<span class="cm">    * as one of its purchases at the given index.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  purchase</span>
<span class="cm">    *         The purchase to check.</span>
<span class="cm">    * @return False if the given index is not positive or exceeds the</span>
<span class="cm">    *         number of purchases for this share + 1.</span>
<span class="cm">    *       | if ( (index &lt; 1) || (index &gt; getNbPurchases()+1) )</span>
<span class="cm">    *       |   then result == false</span>
<span class="cm">    *         Otherwise, false if this share cannot have the given</span>
<span class="cm">    *         purchase as one of its purchases.</span>
<span class="cm">    *       | else if ( ! this.canHaveAsPurchase(purchase) )</span>
<span class="cm">    *       |   then result == false</span>
<span class="cm">    *         Otherwise, true if and only if the given purchase is</span>
<span class="cm">    *         not registered at another index than the given index.</span>
<span class="cm">    *       | else result ==</span>
<span class="cm">    *       |   for each I in 1..getNbPurchases():</span>
<span class="cm">    *       |     (index == I) || (getPurchaseAt(I) != purchase)</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canHaveAsPurchaseAt</span><span class="o">(</span><span class="n">Purchase</span> <span class="n">purchase</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">getNbPurchases</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">canHaveAsPurchase</span><span class="o">(</span><span class="n">purchase</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">getNbPurchases</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">i</span> <span class="o">!=</span> <span class="n">index</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">getPurchaseAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">purchase</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this share has proper purchases attached to it.</span>
<span class="cm">    *</span>
<span class="cm">    * @return True if and only if this share can have each of the</span>
<span class="cm">    *         purchases attached to it as a purchase at the given index,</span>
<span class="cm">    *         and if each of these purchases references this share as</span>
<span class="cm">    *         the share to which they are attached.</span>
<span class="cm">    *       | result ==</span>
<span class="cm">    *       |   for each I in 1..getNbPurchases():</span>
<span class="cm">    *       |     ( this.canHaveAsPurchaseAt(purchase,I) &amp;&amp;</span>
<span class="cm">    *       |       (purchase.getShare() == this) )</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasProperPurchases</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">getNbPurchases</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">canHaveAsPurchaseAt</span><span class="o">(</span><span class="n">getPurchaseAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">i</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">getPurchaseAt</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">getShare</span><span class="o">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Check whether this share has the given purchase as one of its</span>
<span class="cm">    * purchases.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  purchase</span>
<span class="cm">    * 		   The purchase to check.</span>
<span class="cm">    * @return The given purchase is registered at some position as</span>
<span class="cm">    *         a purchase of this share.</span>
<span class="cm">    *       | for some I in 1..getNbPurchases():</span>
<span class="cm">    *       |   getPurchaseAt(I) == purchase</span>
<span class="cm">    */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasAsPurchase</span><span class="o">(</span><span class="nd">@Raw</span> <span class="n">Purchase</span> <span class="n">purchase</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">purchases</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">purchase</span><span class="o">);</span>
        <span class="c1">// A more efficient implementation would be possible if</span>
        <span class="c1">// the consistency imposed on the bi-directional association</span>
        <span class="c1">// would be guaranteed.</span>
        <span class="c1">// return (purchase != null) &amp;&amp; (purchase.getShare() == this);</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Add the given purchase to the list of purchases of this share.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  purchase</span>
<span class="cm">    *         The purchase to be added.</span>
<span class="cm">    * @pre    The given purchase is effective and already references</span>
<span class="cm">    *         this share, and this share does not yet have the given</span>
<span class="cm">    *         purchase as one of its purchases.</span>
<span class="cm">    *       | (purchase != null) &amp;&amp; (purchase.getShare() == this) &amp;&amp;</span>
<span class="cm">    *       | (! this.hasAsPurchase(purchase))</span>
<span class="cm">    * @post   The number of purchases of this share is</span>
<span class="cm">    *         incremented by 1.</span>
<span class="cm">    *       | new.getNbPurchases() == getNbPurchases() + 1</span>
<span class="cm">    * @post   This share has the given purchase as its very last purchase.</span>
<span class="cm">    *       | new.getPurchaseAt(getNbPurchases()+1) == purchase</span>
<span class="cm">    */</span>
    <span class="kt">void</span> <span class="nf">addPurchase</span><span class="o">(</span><span class="nd">@Raw</span> <span class="n">Purchase</span> <span class="n">purchase</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="o">(</span><span class="n">purchase</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">purchase</span><span class="o">.</span><span class="na">getShare</span><span class="o">()</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
        <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">hasAsPurchase</span><span class="o">(</span><span class="n">purchase</span><span class="o">));</span>
        <span class="n">purchases</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">purchase</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Remove the given purchase from the list of purchases of this share.</span>
<span class="cm">    *</span>
<span class="cm">    * @param  purchase</span>
<span class="cm">    *         The purchase to be removed.</span>
<span class="cm">    * @pre    The given purchase is effective, this share has the</span>
<span class="cm">    *         given purchase as one of its purchases, and the given</span>
<span class="cm">    *         purchase does not reference any share.</span>
<span class="cm">    *       | (purchase != null) &amp;&amp;</span>
<span class="cm">    *       | this.hasAsPurchase(purchase) &amp;&amp;</span>
<span class="cm">    *       | (purchase.getShare() == null)</span>
<span class="cm">    * @post   The number of purchases of this share is</span>
<span class="cm">    *         decremented by 1.</span>
<span class="cm">    *       | new.getNbPurchases() == getNbPurchases() - 1</span>
<span class="cm">    * @post    his share no longer has the given purchase as</span>
<span class="cm">    *         one of its purchases.</span>
<span class="cm">    *       | ! new.hasAsPurchase(purchase)</span>
<span class="cm">    * @post   All purchases registered at an index beyond the index at</span>
<span class="cm">    *         which the given purchase was registered, are shifted</span>
<span class="cm">    *         one position to the left.</span>
<span class="cm">    *       | for each I,J in 1..getNbPurchases():</span>
<span class="cm">    *       |   if ( (getPurchaseAt(I) == purchase) and (I &lt; J) )</span>
<span class="cm">    *       |     then new.getPurchaseAt(J-1) == getPurchaseAt(J)</span>
<span class="cm">    */</span>
    <span class="nd">@Raw</span>
    <span class="kt">void</span> <span class="nf">removePurchase</span><span class="o">(</span><span class="n">Purchase</span> <span class="n">purchase</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="o">(</span><span class="n">purchase</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">hasAsPurchase</span><span class="o">(</span><span class="n">purchase</span><span class="o">)</span>
        <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">purchase</span><span class="o">.</span><span class="na">getShare</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">purchases</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">purchase</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**</span>
<span class="cm">    * Variable referencing a list collecting all the purchases in</span>
<span class="cm">    * which this share is involved.</span>
<span class="cm">    *</span>
<span class="cm">    * @invar  The referenced list is effective.</span>
<span class="cm">    *       | purchases != null</span>
<span class="cm">    * @invar  Each purchase registered in the referenced list is</span>
<span class="cm">    *         effective and not yet terminated.</span>
<span class="cm">    *       | for each purchase in purchases:</span>
<span class="cm">    *       |   ( (purchase != null) &amp;&amp;</span>
<span class="cm">    *       |     (! purchase.isTerminated()) )</span>
<span class="cm">    * @invar  No purchase is registered at several positions</span>
<span class="cm">    *         in the referenced list.</span>
<span class="cm">    *       | for each I,J in 0..purchases.size()-1:</span>
<span class="cm">    *       |   ( (I == J) ||</span>
<span class="cm">    *       |     (purchases.get(I) != purchases.get(J))</span>
<span class="cm">    */</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Purchase</span><span class="o">&gt;</span> <span class="n">purchases</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Purchase</span><span class="o">&gt;();</span>

<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="hash-structures">Hash Structures</h1>

<p>Als idee zijn dit een aantal emmertjes. Elke hashcode van een object komt in een emmertje, en als dan een object gezocht wordt berekenen we de hash er van, kijken we in het corresponderende emmertje en zoeken tussen de objecten in dat emmertje het juiste.</p>

<p>Er kunnen meerdere objecten in het zelfde emmertje komen als hun <code>hash modulo #emmertjes</code> gelijk zijn. Als een emmertje drijgt over te lopen dan worden er meerdere emmertjes gemaakt en de objecten opnieuw verdeelt.</p>

<p><img src="/part2/images/emmertjes.png" alt="emmertjes" /></p>


        
    </li>
    
    <li>
        <h1 id="inheritance">Inheritance</h1>

<p>Een subclasse erft over van een superclasse. Alle methods en variabelen worden overgenomen, met als uitzondering constructors. In java mag je slechts overerven van één superclasse. De superclasse waar je van overerft kan wel nog overerven van een andere classe. Als je geen classe op geeft waar je van overerft erf je stiekem toch over van Object.</p>

<p>Overerven doe je met het keyword <code>extends</code> bv <code>public class Painting extends Ownable { ... }</code>.</p>

<p>Abstracte classe: kan je geen objecten van maken, dient enkel om van over te erven. Een abstracte classe kan methods, variabelen en zelfs constructors hebben (maar die laatste kan niet gebruikt worden om er een object van te maken, en enkel aangeroepen worden als deel van een andere constructor.) Je maakt een classe abstract door in zijn heading <code>abstract</code> te zetten.</p>

<p>Een subclasse heeft geen toegang tot private variabelen van de superclasse, de subclasse kan echter wel de getters en setters gedefineerd in de superclasse gebruiken. Een object van de subclasse bevat deze private variabelen echter wel, en maakt er dus geheugen voor, ze compiler laat alleen niet toe dat je ze rechtstreeks aanspreekt.</p>

<p>Een constructor van een subclasse is een volledig nieuwe method. Je moet er dus een volledig nieuwe specificatie voor uitwerken, en niet persé rekening houden met die van de superclasse. Je kan wel de constructor van de superclasse aanroepen in de subclasse door <code>super(...)</code> te gebruiken. (Een andere constructor in de classe zelf kan je aanroepen met <code>this(...)</code>.)</p>

<!--more-->

<h2 id="uml">UML</h2>

<p>In uml geeft een lijn met een <strong>holle</strong> pijl overerving aan.</p>

<p><img src="/part3/images/uml_inheritance.png" alt="inheritance" /></p>


        
    </li>
    
    <li>
        <h1 id="polymorphism">Polymorphism</h1>

<p>Een variabele met een superclasse als type, kan stiekem verwijzen naar een subclasse. In het voorbeeld van de <code>Ownable</code> kan je een variabele van het type <code>Ownable</code> laten verwijzen naar bijvoorbeeld een <code>Painting</code>. Het statische type van de variabele is dan <code>Ownable</code>, maar het dynamische is <code>Painting</code> (het dynamische kan ook veranderen als we bv later beslissen aan die <code>Ownable</code> variabele nu een <code>Dog</code> toe te kennen, vandaar dynamisch).</p>

<p>Je kan dus enkel een object van een specifieker type toekennen aan een variabele van een algemener type. Om het omgekeerde te doen moet je expliciet casten.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//Ownable has .value</span>
<span class="n">Ownable</span> <span class="n">ding</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Painting</span><span class="o">(...);</span>
<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">ding</span><span class="o">.</span><span class="na">value</span><span class="o">;</span> <span class="c1">//OK</span>
<span class="n">string</span> <span class="n">title</span> <span class="o">=</span> <span class="n">ding</span><span class="o">.</span><span class="na">title</span><span class="o">;</span> <span class="c1">//NOT OK, title is a value of Painting, not Ownable</span>

<span class="n">Painting</span> <span class="n">painting</span> <span class="o">=</span> <span class="n">ding</span><span class="o">;</span> <span class="c1">//NOT OK</span>
<span class="n">Painting</span> <span class="n">painting</span> <span class="o">=</span> <span class="o">(</span><span class="n">Painting</span><span class="o">)</span><span class="n">ding</span><span class="o">;</span> <span class="c1">//OK</span></code></pre></div>

<p>Polymorphisme kan ook tussen primitieve types, bv een <code>int</code> toekennen aan een <code>long</code>. Maar eigenlijk wordt dan de int gewoon omgezet in een long. Het statische en dynamische type van primitieve variabelen zijn dus altijd het zelfde.</p>

<p>De compiler gebruikt het statische type om na te gaan of een bepaalde methode kan aangeroepen worden op het object.</p>

<!--more-->

<h2 id="fsuperclass-vs-fsubclass">f(SuperClass) vs f(SubClass)</h2>

<p>Als een classe zowel de functie <code>f(SuperClass)</code> als <code>f(SubClass)</code> heeft, en deze wordt aageroepen, dan bepaald het statische type van de variabele die je er aan mee geeft welke van de twee gebruikt zal worden.</p>

<p>Dus als je de functies <code>f(Ownable par)</code> en <code>f(Dog par)</code> hebt, en je doet het volgende:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Ownable</span> <span class="n">var</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Dog</span><span class="o">();</span>
<span class="n">f</span><span class="o">(</span><span class="n">var</span><span class="o">);</span></code></pre></div>

<p>dan zal de functie <code>f(Ownable par)</code> gebruikt worden, zelfs al zit er eigenlijk een <code>Dog</code> achter.</p>

<h2 id="reflection">Reflection</h2>

<p>Classe zijn eigenlijk ook objecten met als supertype Class. Zo kan je at runtime op eender welk object de methode <code>getClass()</code> oproepen om het Class object er van te krijgen. Dit wordt gebruikt in het 3de voorbeeldje hier onder.</p>

<h2 id="voorbeeldjes">Voorbeeldjes</h2>

<p>Enkele methods uit de classe Person.java die verschillende manieren van checken of een betpaalde variabele eigenlijk naar een ander soort subclasse verwijst:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// The methods listed below illustrate different concepts offered in Java</span>
<span class="c1">// to retrieve information concerning the class to which an object belongs.</span>
<span class="c1">// None of the concepts is superior, meaning that each of the methods</span>
<span class="c1">// can be worked out just as well using the other concepts.</span>
<span class="c1">// In general, one must be very careful to use these concepts. As it will</span>
<span class="c1">// be discussed in later sessions, explicitly asking for the class to which</span>
<span class="c1">// an object belongs sometimes has a negative impact on the adaptability</span>
<span class="c1">// of software systems. However, the definitions of the methods listed</span>
<span class="c1">// below are fully acceptable.</span>

<span class="cm">/**</span>
<span class="cm">* Return the total amount of food needed to feed all dogs</span>
<span class="cm">* owned by this person during the given number of days.</span>
<span class="cm">*</span>
<span class="cm">* @param  days</span>
<span class="cm">*         The given number of days.</span>
<span class="cm">* @return The total amount of food needed to feed all dogs</span>
<span class="cm">*         owned by this person during the given number of days.</span>
<span class="cm">*       | let</span>
<span class="cm">*       |   myDogs = set(dog: Dog | hasAsOwning(dog))</span>
<span class="cm">*       | in</span>
<span class="cm">*       |   result == sum({dog in myDogs : dog.getFoodAmount()})*days</span>
<span class="cm">* @throws IllegalStateException</span>
<span class="cm">*         This person is already terminated.</span>
<span class="cm">*       | isTerminated()</span>
<span class="cm">* @throws IllegalArgumentException</span>
<span class="cm">*         The given number of days is negative.</span>
<span class="cm">*       | days &lt; 0</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="n">BigInteger</span> <span class="nf">getTotalFoodAmount</span><span class="o">(</span><span class="kt">int</span> <span class="n">days</span><span class="o">)</span>
<span class="kd">throws</span> <span class="n">IllegalArgumentException</span><span class="o">,</span> <span class="n">IllegalStateException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isTerminated</span><span class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;Person already terminated!&quot;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">days</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;Negative number of days!&quot;</span><span class="o">);</span>
    <span class="n">BigInteger</span> <span class="n">totalDailyAmount</span> <span class="o">=</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Ownable</span> <span class="n">owning</span> <span class="o">:</span> <span class="n">ownings</span><span class="o">)</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// At this point, we use a type cast to verify whether the given owning</span>
        <span class="c1">// is a dog. A ClassCastException is thrown, if the given owning turns</span>
        <span class="c1">// out not to be dog (or an instance of a subclass of Dog).</span>
        <span class="n">Dog</span> <span class="n">currentDog</span> <span class="o">=</span> <span class="o">(</span><span class="n">Dog</span><span class="o">)</span> <span class="n">owning</span><span class="o">;</span>
        <span class="n">BigInteger</span> <span class="n">currentDailyFoodAmount</span> <span class="o">=</span> <span class="n">BigInteger</span>
            <span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">currentDog</span><span class="o">.</span><span class="na">getDailyFoodAmount</span><span class="o">());</span>
        <span class="n">totalDailyAmount</span> <span class="o">=</span> <span class="n">totalDailyAmount</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentDailyFoodAmount</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassCastException</span> <span class="n">exc</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="o">(!(</span><span class="n">owning</span> <span class="k">instanceof</span> <span class="n">Dog</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">totalDailyAmount</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">days</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm">* Return the car with the largest motor volume owned by this person.</span>
<span class="cm">*</span>
<span class="cm">* @return The resulting car is owned by this person.</span>
<span class="cm">*       | hasAsOwning(result)</span>
<span class="cm">* @return No other car owned by this person has a higher motor volume</span>
<span class="cm">*         than the resulting car</span>
<span class="cm">*       | for each car in Car:</span>
<span class="cm">*       |   if (hasAsOwning(car))</span>
<span class="cm">*       |     then result.getMotorVolume() &gt;= car.getMotorVolume()</span>
<span class="cm">* @throws IllegalStateException</span>
<span class="cm">*         This person is already terminated.</span>
<span class="cm">*       | isTerminated()</span>
<span class="cm">* @throws NoSuchElementException</span>
<span class="cm">*         This person does not own any car.</span>
<span class="cm">*       | for each car in Car: (! hasAsOwning(car)) )</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="n">Car</span> <span class="nf">getMostPowerfulCar</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NoSuchElementException</span><span class="o">,</span>
<span class="n">IllegalStateException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isTerminated</span><span class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;Person already terminated!&quot;</span><span class="o">);</span>
    <span class="n">Car</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Ownable</span> <span class="n">owning</span> <span class="o">:</span> <span class="n">ownings</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// At this point, we use the operator instanceof, which checks whether the</span>
        <span class="c1">// object at its left-hand side belongs to the class at its right-hand side.</span>
        <span class="c1">// The null reference does not belong to any class, and an object of a class</span>
        <span class="c1">// is also an instance of its superclass.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">owning</span> <span class="k">instanceof</span> <span class="n">Car</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Car</span> <span class="n">currentCar</span> <span class="o">=</span> <span class="o">(</span><span class="n">Car</span><span class="o">)</span> <span class="n">owning</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">||</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getMotorVolume</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">currentCar</span><span class="o">.</span><span class="na">getMotorVolume</span><span class="o">()))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">currentCar</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;Person without cars!&quot;</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm">* Return a painting owned by this person and painted by the given painter.</span>
<span class="cm">*</span>
<span class="cm">* @param  painter</span>
<span class="cm">*		   The painter to search for.</span>
<span class="cm">* @return The resulting painting is owned by this person and painted</span>
<span class="cm">*		   by the given painter.</span>
<span class="cm">*       |    hasAsOwning(result)</span>
<span class="cm">*       | &amp;&amp; (result.getPainter() == painter)</span>
<span class="cm">* @throws IllegalStateException</span>
<span class="cm">* 		   This person is already terminated.</span>
<span class="cm">*       | isTerminated()</span>
<span class="cm">* @throws NoSuchElementException</span>
<span class="cm">*		   This person does not own a painting by the given painter.</span>
<span class="cm">*       | for each painting in Painting:</span>
<span class="cm">*       |   (painting.getPainter() != painter) ||</span>
<span class="cm">*       |   (! hasAsOwning(painting)) )</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="n">Painting</span> <span class="nf">getPaintingBy</span><span class="o">(</span><span class="n">Person</span> <span class="n">painter</span><span class="o">)</span>
<span class="kd">throws</span> <span class="n">NoSuchElementException</span><span class="o">,</span> <span class="n">IllegalStateException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isTerminated</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;Person already terminated!&quot;</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Ownable</span> <span class="n">owning</span> <span class="o">:</span> <span class="n">ownings</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// At this point, we use some facilities of reflection offered by Java.</span>
        <span class="c1">// In Java, classes themselves are objects of the predefined class Class.</span>
        <span class="c1">// The expression ClassName.class returns a reference to the object representing</span>
        <span class="c1">// that class; the method getClass() returns a reference to the class to</span>
        <span class="c1">// which the given object belongs.</span>
        <span class="c1">// In this version it is important to use the method isAssignableFrom. If we</span>
        <span class="c1">// had just written ==, an object of a subclass of the class Painting would not</span>
        <span class="c1">// be taken into account then.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Painting</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">owning</span><span class="o">.</span><span class="na">getClass</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">Painting</span> <span class="n">currentPainting</span> <span class="o">=</span> <span class="o">(</span><span class="n">Painting</span><span class="o">)</span> <span class="n">owning</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">currentPainting</span><span class="o">.</span><span class="na">getPainter</span><span class="o">()</span> <span class="o">==</span> <span class="n">painter</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">currentPainting</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">(</span>
        <span class="s">&quot;Person without paintings of given painter!&quot;</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="overriding">Overriding</h1>

<p>Je kan een method van een superclasse herdefinieren door <em>overriding</em>. In de subclasse maak je dan een functie met de zelfde naam en parameter-types en annoteert ze met @Override. Je kan steeds wel de versie in de superclasse aanspreken met <code>super.f(...)</code>.</p>

<p>Voor abstracte functies ben je <strong>verplicht</strong> een override te doen. Als een functie @Final geannoteerd staat in de superclasse dan mag je deze niet overriden. Statische methods kunnen ook niet <em>overridden</em> worden. Voor alle andere functies heb je de keuze of je het wil doen of niet.</p>

<p>Het dynamische type van een variabele bepaald welke versie van een methode word opgeroepen. Als een subclasse een methode override zal deze nieuwe versie aangeroepen worden, zelfs al wordt een variabele van het type van de superclasse gebruikt om deze aan te roepen. Dit gebeurt dus at-runtime.</p>

<p>Statische functies kunnen niet overridden worden. Er wordt dus ook bij het compileren beslist welke versie van de methode word aangeroepen, en hiervoor wordt naar het statische type gekeken.</p>

<!--more-->

<h2 id="object">Object</h2>

<p>Object heeft enkele voorgedefinieerde methodes, zoals <code>toString</code>, <code>equals</code>, <code>clone</code> en <code>hashCode</code>.</p>

<p>toString wordt aangeraden te overriden, maar is niet verplicht.</p>

<p>equals checkt standaard de referenties. Dus voor objecten die de zelfde gegevens hebben (bv twee personen met de zelfde naam), override je dit niet. Als je echter twee verschillende objecten hebt die, hoewel ze hun eigen stukje geheugen hebben, het zelfde zijn, dan override je deze best naar een functie die de inhoud van de objecten na kijkt.</p>

<p>clone geeft standaard een shallow clone. De variabelen worden dus gecopieerd, maar de objecten waar ze mogelijks naar verwijzen niet.</p>


        
    </li>
    
    <li>
        <h1 id="liskov-principle">Liskov Principle</h1>

<p>Het principe komt er op neer dat je altijd een object van de superclasse moet kunnen vervangen door eentje van de subclasse zonder het te merken.</p>

<p><img src="/part3/images/liskov_sub.png" alt="sub" /></p>

<h2 id="class-invarianten">Class Invarianten</h2>

<p>Een subclasse mag nooit classe invarianten verwijderen of verzwakken. Het versterken van bestaande of toevoegen van nieuwe classe invarianten mag wel. Syntactisch moet je niet alle classe invarianten herhalen van de superclasse, enkel de aangepaste en toegevoegde, de bestaande worden verondersteld ook te gelden.</p>

<p>Als bijvoorbeeld de superclasse zegt dat variabel <code>x</code> tussen 5 en 10 moet liggen, dan moet dit in de subclasse ook zijn. De classe invariant van de subclasse mag deze wel versterken, naar bijvoorbeeld <code>x</code> tussen 7 en 8, maar niet verzwakken naar <code>x</code> tussen 3 en 9.</p>

<p>Het versterken van zulke classe invarianten kan ook door het herdefinieren van checkers. Als je bijvoorbeeld een checker had <code>hasProperX(x)</code> is de superclasse (gebruikt in zijn classe invariant), en je herdefinieerd deze, dan heb je de classe invariant van de subclasse versterkt zonder dit nog eens expliciet er bij te schrijven.</p>

<p><img src="/part3/images/liskov_invar.png" alt="invar" /></p>

<h2 id="postcondities">Postcondities</h2>

<p>Postcondities mag je steeds versterken of toevoegen. Niet verzwakken. Net zoals classe invarianten. Je moet bestaande ook niet herhalen.</p>

<p><img src="/part3/images/liskov_post.png" alt="post" /></p>

<h2 id="precondities">Precondities</h2>

<p>Precondities zijn wel heel anders. Deze mag je net niet versterken, noch nieuwe precondities toevoegen. Ja mag de bestaande precondities wel verzwakken of weg laten.</p>

<p>Bijvoorbeeld, als de superclasse een preconditie heeft die zegt dat de parameter <code>a</code> tussen 0 en 10 ligt, dan mag de subclasse deze conditie aanpassen naar <code>a</code> tussen -10 en 20, maar niet naar <code>a</code> tussen 2 en 11.</p>

<p>Opgelet, in tegenstelling tot poscondities en classe invarianten, als je bij precondities een conditie niet opnieuw schrijft wordt ze verondersteld niet langer te gelden. Als je dus de precondities onveranderd wilt laten moet je ze allemaal opnieuw schrijven.</p>

<p><img src="/part3/images/liskov_pre.png" alt="pre" /></p>

<h2 id="argumenten">Argumenten</h2>

<p>Volgens Liskov kunnen argumenten enkel verzwakt worden. Zo mag je van <code>Woman</code> een <code>Person</code> maken, maar niet omgekeerd. <strong>Java laat dit echter niet toe</strong>, de parameter-types moeten dus altijd het zelfde blijven.</p>

<p><img src="/part3/images/liskov_args.png" alt="args" /></p>

<h2 id="return">Return</h2>

<p>Return waardes zijn vrijwel het zelfde als postcondities. Als een superclasse als return-type <code>Person</code> heeft dan mag de subclasse deze aanpassen naar bv <code>Man</code> maar niet naar bv <code>Mammal</code>. (Hier erft <code>Man</code> over van <code>Person</code>, die op zijn beurt over erft van <code>Mammal</code>.)</p>

<p><img src="/part3/images/liskov_return.png" alt="return" /></p>

<h2 id="exceptions">Exceptions</h2>

<p>De lijst van exceptions die een methode kan smijten mag verklijnd worden, maar niet uitgebreid. Je mag ook een bepaalde exception vervangen door een specifiekere versie er van (eentje die er van over erft). Java support dit, maar enkel voor checked exceptions, voor unchecked laat hij alles toe. Het is echter best dat je zelf wel <em>altijd</em> rekening houdt met dit principe (voor unchecked exceptions ook dus).</p>

<p><img src="/part3/images/liskov_exceptions_set.png" alt="except" /></p>

<p>De reden voor het smijten van exceptions valt onder twee categorieen: wanneer ze <strong>moeten</strong> gesmeten worden, en wanneer ze <strong>mogen</strong> gesmeten worden.</p>

<p>De reden waarom een exception gesmeten <strong>moet</strong> worden mag niet veranderd worden (noch verzwakt, noch versterkt).</p>

<p>Een reden waarom een exception gesmeten <strong>mag</strong> worden kan je als volgt geven: <code>@throws ... | mustThrow ? canThrow</code>. Hier is ‘mustThrow’ een conditie waar de exception moet gesmeten worden (en deze moet dus onveranderd blijven), en ‘canThrow’ een conditie waarin de exception gesmeten mag worden (deze is standaard <code>false</code> en laat je dan gewoon weg). Delen vand de <em>state</em> waar niet over gesproken wordt (5 tot … in <code>x &lt; 5</code> bv) worden verondersteld veilig te zijn, en dus nooit een exception te smijten. Een method mag het deel waar gesmeten <em>mag</em> worden verkleinen (<code>x &lt; 5</code> -&gt; <code>x &lt; 3</code>) maar niet vergroten.</p>

<p>Je kan het ook een beetje combineren. Zo kunnen delen waar in de superclasse een exception gesmeten <strong>mag</strong> worden verschoven worden naar een deel waar ze nu <strong>moet</strong> gesmeten worden. In de afbeelding hier onder <strong>mag</strong> de exception gesmeten worden vanaf <code>10 000</code>, bij de overriden <strong>moet</strong> ze gesmeten worden vanaf <code>20 000</code>. Dit is dus ook ok. Je zou ze echter niet mogen specifieren dat de exception dan <em>moet</em> gesmeten woden vanaf bv <code>5 000</code> want dit was een deel waar in de superclasse niets over gezegd werd en dat wilt zeggen dat ze dan niet gesmeten mag worden.</p>

<p><img src="/part3/images/liskov_exceptions_reason.png" alt="execpt reason" /></p>

<h2 id="access-rights">Access Rights</h2>

<p>Je mag de access rights van een overridden functie uitbreiden, maar niet doen krimpen. Zo mag je van een <code>private</code> functie een <code>public</code> functie maken, maar niet omgekeerd.</p>

<p><img src="/part3/images/liskov_access.png" alt="access" /></p>


        
    </li>
    
    <li>
        <h1 id="interfaces">Interfaces</h1>

<p>Een interface introduceert één of meerdere functies. Deze functies zijn altijd public en abstract.</p>

<p>Sinds Java8 kunnen er ook default functie implementaties in interfaces gegeven worden. Functies die dit hebben worden aangeduid met <code>default</code>.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SomeInterface</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">constante</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">abstractMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">);</span>

    <span class="c1">//sinds Java 8</span>
    <span class="kd">public</span> <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">defaultMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">abstractMethod</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//sinds Java 8</span>
    <span class="kd">public</span> <span class="k">default</span> <span class="kt">void</span> <span class="nf">defaultMethod2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Hello from default method 2!&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//sinds Java 8</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Hello from Interface!&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>Een classe kan zo veel interfaces implementeren als hij maar wil, op bijna de zelfde manier als het overerven van een classe:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span>
    <span class="kd">extends</span> <span class="n">OtherClass</span>
    <span class="kd">implements</span> <span class="n">AnInterface</span><span class="o">,</span> <span class="n">AnotherInterface</span>
<span class="o">{...}</span></code></pre></div>

<p>Een interface kan andere interfaces implementeren. De SubInterface kan bestaande methods dan een <code>default</code> implementatie geven, ze worden dan ook geannoteerd met <code>@Override</code>. Ze subinterface kan ook <code>default</code> methods on-implementeren. (Zie ‘meer’ voor voorbeeld.)</p>

<p>Als een classe meerdere interfaces inplementeerd, die elks een functie met de zelfde signatuur hebben, dan worden deze functies samen één functie.</p>

<!--more-->

<h2 id="onimplementeren-van-default-methods">(On)Implementeren van default methods</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SubInterface</span> <span class="kd">extends</span> <span class="n">SomeInterface</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="c1">// Implementation of inherited abstract method.</span>
    <span class="kd">public</span> <span class="k">default</span> <span class="kt">int</span> <span class="nf">abstractMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Un-implementation of inherited default method.</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">defaultMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">);</span>

    <span class="c1">// Invocation of super-version.</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="k">default</span> <span class="kt">void</span> <span class="nf">defaultMethod2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">SomeInterface</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">defaultMethod2</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="meerdere-interfaces-implementeren-met-de-zelfde-method">Meerdere interfaces implementeren met de zelfde method</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">abstractMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">);</span>

    <span class="kd">public</span> <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">defaultMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span> <span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="k">default</span> <span class="kt">int</span> <span class="nf">abstractMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">defaultMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I12</span>
    <span class="kd">extends</span> <span class="n">I1</span><span class="o">,</span> <span class="n">I2</span>
<span class="o">{</span>
    <span class="c1">// methods worden samengevoegd</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">abstractMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">defaultMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="special-classes">Special Classes</h1>

<h2 id="static-member-classes">Static Member Classes</h2>

<p>Een classe kan gedefinieerd worden als een statische classe in een andere classe. Deze <em>static member classes</em> hebben toegang tot de private variabelen van de omringende classe, als ook tot de private variabelen van andere <em>static members classes</em> in de omringende classe. Geneste classe kunnen variabelen met de zelfde naam hebben als hun ouder.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">EnclosingClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">NestedClass</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>Deze geneste classen kunnen van buitenaf aangesproken worden met <code>EnclosingClass.NestedClass</code> (eventueel met nog extra packages er voor). In de <em>enclosing class</em> zelf moet ken je gewoon rechtstreeks <code>NestedClass.Tralala</code> gebruiken.</p>

<h2 id="non-static-member-classes">Non-static Member Classes</h2>

<p>Bijna het zelfde, maar kunnen geen statische variabelen of methods bevatten. (Wel final static variabelen.) Men noemt deze <em>inner classes</em>. Een enclosing class en inner class hangen steeds samen, vanaf dat new gedaan is kan je ze niet meer uit elkaar halen, in essentie is de inner class dus een beetje <em>final</em>.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">EnclosingClass</span> <span class="n">enclosingObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">EnclosingClass</span><span class="o">();</span>
<span class="n">NestedClass</span> <span class="n">nestedObject</span> <span class="o">=</span> <span class="n">enclosingObject</span><span class="o">.</span><span class="na">new</span> <span class="nf">NestedClass</span><span class="o">();</span></code></pre></div>

<p>Vanuit een inner-class kan je de bovenliggende aanspreken met <code>EnclosingClassName.this</code> (de inner class zelf met <code>this</code>). Als je een method aanroept in de inner class, en de inner class heeft geen method met die naam, dan wordt er gekeken naar de enclosing classe. Als zowel de inner class als enclosing class een method met de zelfde naam hebben, en de inner class roept deze aan, dan zal de versie van de inner class voorrang krijgen.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span>
<span class="nc">EnclosingClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enclMethod</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">NestedClass</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nestedMethod</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">enclMethod</span><span class="o">();</span> <span class="n">EnclosingClass</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">enclMethod</span><span class="o">();</span>
            <span class="n">staticMethod</span> <span class="o">();</span> <span class="n">EnclosingClass</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="local-classes">Local Classes</h2>

<p>Je kan ook een classe aanmaken in een functie van een andere classe. Deze implementeren vaak een interface (of abstracte classe) die buiten de functie ook gekend is.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">EnclosingClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">g</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>

        <span class="kd">class</span> <span class="nc">LocalClass</span> <span class="kd">implements</span> <span class="n">SomeInterface</span> <span class="o">{</span>

            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nestedMethod</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">SomeInterface</span> <span class="n">some</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">LocalClass</span><span class="o">();</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="anonymous-classes">Anonymous Classes</h2>

<p>Als je een locale classe wilt maken, maar je wilt er maar één van, dan kan je dit doen zonder de classe een naam te geven.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">EnclosingClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">g</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">SomeInterface</span> <span class="n">some</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">SomeInterface</span><span class="o">()</span> <span class="o">{</span> <span class="c1">//of bv new SomeClass(arg1, arg2, ...)</span>
            <span class="o">...</span>
        <span class="o">}</span>

        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


        
    </li>
    
    <li>
        <h1 id="streams">Streams</h1>

<p><img src="/part4/images/stream.png" alt="inheritance" /></p>

<p>Doe enkele operaties op een stream van objecten. Filter en map methodes (<em>intermediate methods</em>) returnen een stream waar weer meer operaties op gedaan kunnen worden. Een terminate method beindigd de stream en geeft niet langer een stream terug (<code>boolean allMatch(Predicate&lt;? super T&gt; predicate)</code>, <code>void forEach(Consumer&lt;? super T&gt; action)</code>, <code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code>).</p>

<!--more-->

<h2 id="parallel-streams">Parallel Streams</h2>

<p>Je kan ook een parallel stream maken, deze gebruikt dan mogelijk meerdere threads om alles te doen.</p>


        
    </li>
    
    <li>
        <h1 id="functional-interfaces">Functional Interfaces</h1>

<p>Je kan een interface aanduiden als <em>functional</em> met @FunctionalInterface. De compiler checkt dan dat er één abstracte methode is. Deze annotatie is niet persee nodig, maar de compiler zal u vertellen als je er perongeluk te veel methodes in hebt steken. Java heeft al enkele van deze interfaces voorgedefinieerd:</p>

<ul>
  <li>Predicate<t>, met methode `boolean test(T t)`</t></li>
  <li>Function&lt;T,R&gt;, met methode <code>R apply(T t)</code></li>
  <li>Consumer<t>, met methode `void accept(T t)` (voert de functie uit op alles in de stream)</t></li>
  <li>Supplier<t>, met methode `T get()`</t></li>
  <li>BiFunction&lt;T,U,R&gt;</li>
  <li>en nog veel meer!</li>
</ul>


        
    </li>
    
    <li>
        <h1 id="lambdas">Lambdas</h1>

<p>Anonieme functies. De functie <code>Long plus(Long a, Long b) { return a + b; }</code> kan je anoniem schrijven als <code>(Long a, Long b) -&gt; a+b</code>.</p>

<p>Als de lambda functie meerdere parameters heeft moeten er haakjes rond, en commas tussen. Als er slechts één parameter is kan je de haakjes weg laten. Zonder parameters moet je haakjes zetten zonder iets tusesn <code>()</code>. Je mag zelfs de types weg laten van je functie, de compiler verzint dan wel zelf wat ze moeten zijn: <code>(a, b) -&gt; a+b</code>.</p>

<p>Als een lambda functie non-static variabelen gebruikt van buiten de lambda functie zelf, dan worden deze <em>captured</em>, en er wordt dus een eigen copietje bij gehouden voor de lambda functie.</p>


        
    </li>
    
    <li>
        <h1 id="generic-classes">Generic Classes</h1>

<p>Je kan een class definieren rond enkele nog ongekende types. Deze types kan je dan later invullen. De gekozen types kunnen enkel reference types zijn, geen primitieve types (omdat ze in de achtergrond gwn naar Object worden omgezet).</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericClass</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">S</span> <span class="nf">someMethod</span><span class="o">(</span><span class="n">T</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">S</span> <span class="n">localVar</span><span class="o">;</span> <span class="c1">//OK</span>
        <span class="n">S</span> <span class="n">otherVar</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">S</span><span class="o">();</span> <span class="c1">//NOT OK, geen new S() mogelijk</span>

        <span class="n">S</span><span class="o">[]</span> <span class="n">localArray</span><span class="o">;</span> <span class="c1">//OK</span>
        <span class="n">S</span><span class="o">[]</span> <span class="n">otherArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">S</span><span class="o">[];</span> <span class="c1">//NOT OK.</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>Bij het instantieren van deze classe geef je dan types mee: <code>new GenericClass&lt;Integer,Person&gt;(...)</code> (maar niet <code>new GenericClass(int, Person)</code> want int is een primitief type). Als je dan <code>someMethod</code> wilt aanroepen zal je een Person moeten meegeven. (Je kan ook nog steeds <code>new GenericClass(...)</code> doen, zonder types, dan wordt voor allemaal <code>Object</code> verondersteld, maar de compiler zal hier een warning voor geven. Dit is voor backwards compatibility.)</p>

<h2 id="compilatie">Compilatie</h2>

<p>Als zo’n generische classe gecompileerd wordt worden alle generische types omgezet naar <code>Object</code>, en er wordt dus slechts één classe gecompileerd (in tegenstelling tot bv C++). Dit geeft soms rare gevolgen, want casten naar één van de generische types wordt dus eigenlijk casten naar Object, totaal nutteloos dus!</p>

<h2 id="polymorphism">Polymorphism</h2>

<p>Hoewel <code>Integer</code> een subtype is van <code>Number</code>, is <code>List&lt;Integer&gt;</code> dat niet van <code>List&lt;Number&gt;</code>, maar bij arrays wel: <code>Integer[]</code> is een subtype van <code>Number[]</code>.</p>


        
    </li>
    
    <li>
        <h1 id="wildcards">Wildcards</h1>

<p>Een wildcard wordt geschreven als <code>?</code>. Zo is List&lt;?&gt; supertype van alle instantiaties van List. Als je een <code>List&lt;? &gt; myList</code> hebt, dan is het volgende perfect mogelijk: <code>myList.add(new Integer())</code>, or worden geen types nagekeken. Zo kan ook <code>Object o = myList.get(0)</code> gebruikt worden.</p>

<h2 id="upperbound">Upperbound</h2>

<p>Je kan zo’n wildcard een upperbound geven: <code>List&lt;? extends Number&gt;</code> bijvoorbeeld. Dit is dus een lijst van <strong>één</strong> van de subtypes van Number. Hier kan je geen <code>Integer</code> aan toevoegen. Een <code>List&lt;? extends Number&gt;</code> is wel het supertype van <code>List&lt;Integer&gt;</code>.</p>

<p>Achter een <code>List&lt;? extends Number&gt;</code> kan dus een lijst vol <code>Double</code>s zitten, vandaar dat je er geen <code>Integer</code> of <code>Number</code> aan kan toevoegen. Je weet wel zeker dat de objecten die er in zitten in een <code>Number</code> variabele gestoken kunnen worden.</p>

<p>Je gebruikt dit als je uit de lijst Numbers wilt kunnen halen: <code>Number nummerke = list.get(0)</code> (als list van het type <code>List&lt;? extends Number&gt;</code> is).</p>

<h2 id="lowerbound">Lowerbound</h2>

<p>Een lower bound kan je aangeven met: <code>List&lt;? super Number&gt;</code>. Dit is een lijst van <strong>één</strong> van de supertypes van Number (of Number zelf).</p>

<p>Je gebruikt dit als je in de lijst elementen wilt kunnen bij steken: <code>list.add(new Integer(...))</code>. Ja kan echter geen types hoger dan <code>Number</code> toevoegen, dus niet: <code>list.add(new Object())</code>.</p>

<p>Als je er een een object uit wil halen kan je alleen zeker zijn dat het van het type <code>Object</code> zal zijn.</p>

<h2 id="generics">Generics</h2>

<p>Je kan deze upper- en lowerbounds ook gebruiken voor generische classe: <code>public class GenericSubClass&lt;S extends Number,T&gt;</code>.</p>


        
    </li>
    
    <li>
        <h1 id="generic-methods">Generic Methods</h1>

<p>Gebruikte generische parameter types zet je <em>voor</em> het return type (<code>&lt;T&gt; int f...</code>).</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">genericMethod</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">coll</span><span class="o">)</span>
<span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">genericMethod</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">coll</span><span class="o">,</span> <span class="n">Iterator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;)</span>
<span class="o">{</span> <span class="o">...</span> <span class="o">}</span></code></pre></div>

<p>Bij het aanroepen mag je expliciet de types mee geven, maar dit is niet nodig, de compiler kan zelf verzinnen welke ze moeten zijn aan de hand van de parameters die je mee geeft. De compiler zal komen klagen als je verkeerde mee geeft, of als hij er geen juiste kan afleiden uit je parameters.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">theCollection</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">theIterator</span> <span class="o">=</span> <span class="o">...;</span>

<span class="n">TheClass</span><span class="o">.&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">genericMethod</span> <span class="o">(</span><span class="n">theCollection</span><span class="o">,</span> <span class="n">theIterator</span><span class="o">);</span>
<span class="n">TheClass</span><span class="o">.</span><span class="na">genericMethod</span><span class="o">(</span><span class="n">theCollection</span><span class="o">,</span> <span class="n">theIterator</span><span class="o">);</span></code></pre></div>


        
    </li>
    
</ul>

    </body>
</html>
